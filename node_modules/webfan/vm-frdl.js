/*! webfan (C) Till Wehowski, Webfan.de - All rights reserved. */
/*!*usage:
*   vm = require('webfan/vm-frdl');
**/
/*! thank you to: https://github.com/dfkaye/vm-shim !*/
/*!* node.js :
Class: vm.Script

    new vm.Script(code, options)
    script.runInContext(contextifiedSandbox[, options])
    script.runInNewContext([sandbox][, options])
    script.runInThisContext([options])

vm.createContext([sandbox])
vm.isContext(sandbox)
vm.runInContext(code, contextifiedSandbox[, options])
vm.runInDebugContext(code)
vm.runInNewContext(code[, sandbox][, options])
vm.runInThisContext(code[, options])
*/


// vm-shim.js
/*
https://github.com/dfkaye/vm-shim
*/
(function(){
	
'use strict';


  if (typeof global === 'undefined' && window) {
  
    // bit from substack's iframe based vm-browserify at
    // https://github.com/substack/vm-browserify/blob/master/index.js#L37-40
    if (!window.eval && window.execScript) {
        // win.eval() magically appears when this is called in IE:
        window.execScript('null');
    }
  
    global = window;
  }
  
 var frdl = require('frdl'); // frdl library : http://api.webfan.de/api-d/4/js-api/library.js 
 var util = require('util');
 var util_opts = {
 	showHidden : true,
    depth : 4
 };  
 var vm = new frdl.EventEmitter;

 





 
 
 

(function(){
	


'use strict';




// vm-shim.js
/*
https://github.com/dfkaye/vm-shim
*/
  // src may be a string or a function
  // context is a config object of properties to be used as vars inside the new scope 
  //contextifiedSandbox, options
  function runInContext(src, context/*, filename*/, options) {
    
    var code = "'use strict';", key;
    
    // before - set local scope vars from each context property
    for ( key in context) {
      if (context.hasOwnProperty(key)) {
        code += 'var ' + key + ' = context[\'' + key + '\'];\n';
      }
    }
    
    typeof src === 'string' || (src = '(' + src.toString() + '())');
    
    code += src + ';\n';
    
    // after - scoop changes back into context
    for ( key in context) {
      if (context.hasOwnProperty(key)) {
        code += 'context[\'' + key + '\'] = ' + key + ';\n';
      }
    }
    
    return sandboxRun(function () {
      Function('context', code).call(null, context);
      return context;
    });
  }
  
  // param src - may be a string or a function
  // param context - config object of properties to be used as vars inside the new scope  
  function runInNewContext(src, context/*, filename*/, options) {

    context = context || {};
    
    // Object.create shim to shadow out the main global
    function F(){};
    F.prototype = (typeof Window !== 'undefined' && Window.prototype) || global;
    context.global = new F;
    
    // This statement resets vm references in the new sandbox:
    // + fixes browser reference if vm is not passed in (so we don't provide it)
    // + fixes node.js reference if vm is passed in (make it available to new global)
    context.global.vm = context.vm = context.vm;
    
    return runInContext.apply(context.global, [src, context/*, filename*/]);
  }

  // src may be a string or a function
  function runInThisContext(src/*, filename*/, options) {
  
    var code = src;
    
    
     // De-Compiling to string defeating purpose ?-
   //  if (typeof src == 'function') {
   //    code = src.toString();
   //    code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}') - 1);
  //   }

    return sandboxRun(function () {
     //   if('function' === typeof code){
	 //   	 return code();
	 //   }	
        if('function' === typeof code){
           code = code.toString();
           code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}') - 1);
	    }	 
      return eval(code);
    });
  }
  
  // method sandbox - helper function for scrubbing "accidental" un-var'd globals after 
  // eval() and Function() calls. 
  // + Inconveniently, eval() and Function() don't take functions as arguments.  
  // + eval() leaks un-var'd symbols in browser & node.js.
  // + indirect eval() leaks ALL vars globally, i.e., where var e = eval; e('var a = 7'); 
  //   'a' becomes global, thus, defeating the purpose.
  function sandboxRun(fn) {
   
   'use strict';
   
    var keys = {};
    
    for (var k in global) {
      keys[k] = k;
    }
    
    var result = fn();
    
    for (var k in global) {
      if (!(k in keys)) {
        delete global[k];
      }
    }
    
    return result;
  }





 
 
 
 
  // bind all methods to this Script object
  // - Script(code, { filename = "evalmachine.anonymous",
//                  displayErrors = true } = {})
//   with methods:
//   - runInThisContext({ displayErrors = true } = {})
//   - runInContext(sandbox, { displayErrors = true, timeout = undefined } = {})
// - makeContext(sandbox) //createContext??
// - isContext(sandbox)

function makeContext(sandbox){
	  sandbox = sandboxRun(function(){
	  	 return frdl.clone(sandbox);
	  });
	  return sandbox;
}



function isContext(sandbox){
	return (sandbox === makeContext(sandbox)) ? true : false;
}


/*
	   	  	 var module = new frdl.TTypes.TModule(location.href);
	   	  	 module.descriptor =  module.resolve(location.href);	
	   	  	 module.parent = arguments[0];   	  
  	         module.sourceURL = location.href + AnchorPrefix +k;	 
  	         module.source = compiler('\n' + headercode + '\n' +inlinecode, module);
  	         
  	        
      try{	

	  module = eval(module.source);
	  var error = false;
	  var state = 'resolved';
    }catch(err) {
    	module = undefined;
	    console.error(err);
	    var error = err;
	    var state = 'rejected';
    }	
    */
// From this we build the entire documented API.
  // exports all its methods to the Script object
 function ScriptVM(code, options){
 	
 	this.options=frdl.extend({
 		filename : (__DIR__ || '://') + '#@vm:' + frdl.Sha1.hash(code)
 	}, options ||  {});	
 	
 	
	if(this.options.compile && 'function'===typeof this.options.compile){
	   this.code=this.options.compile.apply(this, [code]);
	}else if(this.options.compile && 'string'===typeof this.options.compile && 'text/typescript'===this.options.compile){
	  var module = new frdl.TTypes.TModule(this.options.filename);
	  module.parent = (this.options.module && true===this.options.module instanceof frdl.TTypes.TModule) ? this.options.module : new frdl.TTypes.TModule((__DIR__ || '://'));
	  module.sourceURL = this.options.filename;
	   var headercode = frdl.require('5:http://'+frdl.route('HOST_CDN_PUBLIC_FRDL')+'/cdn/application/webfan/node_modules/webfan/frdl.d.ts.txt', false, frdl.require.getCompiler('text/plain'), 'text/plain').content;
	  module.source = frdl.require.getCompiler('application/typescript')('\n' + headercode + '\n' +  code, module);
	  this.code = module.source;
	}else if(this.options.compile && 'string'===typeof this.options.compile && 'text/javascript'===this.options.compile){
	  var module = new frdl.TTypes.TModule(this.options.filename);
	  module.parent = (this.options.module && true===this.options.module instanceof frdl.TTypes.TModule) ? this.options.module : new frdl.TTypes.TModule((__DIR__ || '://'));
	  module.sourceURL = this.options.filename;
	  module.source = frdl.require.getCompiler('application/javascript')('\n' +  code, module);
	  this.code = module.source;
	}else{
 	   this.code=code;		
	}


 	
 //script.runInContext(contextifiedSandbox[, options])
 this.runInContext = function(contextifiedSandbox, options){
    var opts = frdl.extend(this.options, (options || {}));
    return runInContext.call(contextifiedSandbox, this.code, contextifiedSandbox, opts);
 };
 
 
 //script.runInNewContext([sandbox][, options])
 this.runInNewContext = function(sandbox, options){
     var context = vm.createContext(sandbox);
     var opts = frdl.extend(this.options, (options || {}));
     return runInContext.call(this, this.code,  context, opts);	
 };
 
 //script.runInThisContext([options])
 this.runInThisContext = function(options){
         var opts = frdl.extend(this.options, (options || {}));
 	     return runInThisContext.call(null, this.code,  opts);	
 }; 	
 	
  return this;
}
 

 
 
 

 
 
 
/**
Class: vm.Script
*/
/**
new vm.Script(code, options)
#
Added in: v0.3.1

    code <string> The JavaScript code to compile.
    options
        filename <string> Specifies the filename used in stack traces produced by this script.
        lineOffset <number> Specifies the line number offset that is displayed in stack traces produced by this script.
        columnOffset <number> Specifies the column number offset that is displayed in stack traces produced by this script.
        displayErrors <boolean> When true, if an Error error occurs while compiling the code, the line of code causing the error is attached to the stack trace.
        timeout <number> Specifies the number of milliseconds to execute code before terminating execution. If execution is terminated, an Error will be thrown.
        cachedData <Buffer> Provides an optional Buffer with V8's code cache data for the supplied source. When supplied, the cachedDataRejected value will be set to either true or false depending on acceptance of the data by V8.
        produceCachedData <boolean> When true and no cachedData is present, V8 will attempt to produce code cache data for code. Upon success, a Buffer with V8's code cache data will be produced and stored in the cachedData property of the returned vm.Script instance. The cachedDataProduced value will be set to either true or false depending on whether code cache data is produced successfully.

Creating a new vm.Script object compiles code but does not run it. The compiled vm.Script can be run later multiple times. It is important to note that the code is not bound to any global object; rather, it is bound before each run, just for that run.
*/
//new vm.Script(code, options)  [FACTORY]
function Script(code, options) {
  if (!(this instanceof Script)) {
     return new Script(code, options);
  }


  var THAT = this;
  

  /**
  Transpile all function...
  */
  var Transpiled = new ScriptVM(code, options);
   



	
	
	
   frdl.each(Object.keys(Transpiled), function(i, f){
   	

      THAT[f] = function() {
        if (!(this instanceof Script)) {
          throw new TypeError('invalid call to ' + f);
        }
        return Transpiled[f].apply(Transpiled, arguments);
      };
      
   });


  return THAT;
}



function createScript(code, options) {
  return new Script(code, options);
};




Script.prototype.createScript = Script.createScript = createScript; 




/**
Class: vm.Script

    new vm.Script(code, options)
    script.runInContext(contextifiedSandbox[, options])
    script.runInNewContext([sandbox][, options])
    script.runInThisContext([options])

vm.createContext([sandbox])
vm.isContext(sandbox)
vm.runInContext(code, contextifiedSandbox[, options])
vm.runInDebugContext(code)
vm.runInNewContext(code[, sandbox][, options])
vm.runInThisContext(code[, options])
*/


vm.createScript = function(code, options) {
  return Script.prototype.createScript.apply(null, [code, options]);
};




vm.runInDebugContext = function(code) {
 /*  return binding.runInDebugContext(code); */
 throw 'runInDebugContext is not implemented yet!';
};

vm.runInContext = function(code, contextifiedSandbox, options) {
  var script = new Script(code, options);
  return script.runInContext(contextifiedSandbox, options);
};

vm.runInNewContext = function(code, sandbox, options) {
  var script = new Script(code, options);
  return script.runInNewContext(sandbox, options);
};

vm.runInThisContext = function(code, options) {
  var script = new Script(code, options);
  return script.runInThisContext(options);
};

vm.isContext = function(sandbox) {
  return isContext(sandbox);
};

vm.createContext = function(sandbox) {
  if (sandbox === undefined) {
    sandbox = {};
  }  else if (true===vm.isContext(sandbox)) {
    return sandbox;
  }
  return makeContext(sandbox);
};







vm.Script = Script;
exports = module.exports = vm;
}());

}());
